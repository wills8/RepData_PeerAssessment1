install.packages ("gdal")
install.packages ("rgdal")
install.packages ("ggplot2")
library(ggplot2)
search()
install.package ("KernSmooth")
package.install ("KernSmooth")
install.packages("KernSmooth")
library(KernSmooth)
## This is a markdown file
getwd
getwd()
cube <- function(x,n) {
x^3
}
cub(3)
cube(3)
x <- 1:10
if(x>5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
x <- list(a =  1:8, b = rnorm(125))
lapply(x, mean)
?gl
install.packages("swirl")
library(swirl)
install_from_swirl("R Programming")
swirl()
library(datasets)
data(iris)
?iris
head(iris)
dat <- data(iris)
bad <- is.na(dat)
clean_data <- dat[!dat]
nrow(clean_data)
dat <- data(iris)
bad <- is.na(dat)
clean_data <- dat[!bad]
nrow(clean_data)
bad <- is.na(iris)
dat <- iris[!bad]
nrow(dat)
bad <- is.na(iris)
dat <- iris[!bad]
head(dat)
dat <- complete.cases(iris)
head(dat)
head(iris)
nrow(iris)
?subset
subset(iris, Species == virginica, select = Petal.Length)
subset(iris, Species == "virginica", select = Petal.Length)
mean(subset(iris, Species == "virginica", select = Petal.Length))
dat <- subset(iris, Species == "virginica", select = Petal.Length)
head(dat)
?mean
mean(dat, na.rm = TRUE)
mean(dat[["Petal.Length"]])
print(iris)
head(iris)
colMean(iris)
colMeans(iris)
apply(iris,2,mean)
apply(iris[,1:4],1,mean)
apply(iris[,1:4],2,mean)
data(mtcars)
head(mtcars)
with(mtcars, tapply(mpg, cyl, mean))
apply(mtcars, 2, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
lapply(mtcars, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
mean(mtcars$mpg, mtcars$cyl)
split(mtcars, mtcars$cyl)
sapply(mtcars, cyl, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
sapply(split(mtcars$hp, mtcars$cyl), mean)
?abs
abs(209.21429-82.63636)
debug(ls)
## The makeCacheMatrix and cacheSolve functions are used to reduce the need
## of recaculating the inverse of a matrix repeatedly in a loop by caching the
## the inverse of the specified matrix. The makeCacheMatrix is used to create a
## special "matrix" to store the inverse and the cacheSolve function is used to
## compute the inverse of the created matrix if the value is not already in
## the cache.
## The makeCacheMatrix function creates a special "matrix", which is really a
## special list containing a function to set the value of the matrix, get the
## value of the matrix, set the value of the inverse, and get the value of the
## inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
set_inverse <- function(inverse) m <<- inverse
get_inverse <- function() m
list(set = set, get = get,
set_inverse = set_inverse,
get_inverse = get_inverse)
}
## The cacheSolve function calculates the inverse of the matrix created
## if the value of the inverse is not already stored in the cache.
## If the value is stored in cache, the funciton skips the computation
## and retrieves the value from cache.
cacheSolve <- function(x, ...) {
m <- x$get_inverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$set_inverse(m)
m
}
mat <- matrix(1:4, 2, 2)
mat
makeCacheMatrix(mat)
g <- makeCacheMatrix(mat)
cacheSolve(g)
solve(g)
solve(mat)
install.packages("RMySQL")
install.packages("Rtools")
install.Rtools()
?rtools
install.packages("MySQL")
install.packages("RMySQL")
library(RMySQL)
ucscDB <- dbConnect(MySQL(), user = "genome", host = "genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDB, "show databases;"); dbDisconnect(ucscDB);
View(result)
source("http://bioconductor.org/biocLite.R")
biocLite("rhdf5")
library(rhdf5)
create = h5createFile("example.h5")
created
library(nlme)
library(lattice)
xyplot(weight ~ Time | Diet, BodyWeight)
setwd("~/JH_DataScience/R_Directory/reproducibleProj1/RepData_PeerAssessment1")
